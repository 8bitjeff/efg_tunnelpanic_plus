package com.efg.framework{	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;		/**	 * ...	 * @author Jeff Fulton	 */	public class BlitBitmap extends Bitmap{		private var bitmap:Bitmap;		private var tileSheet:TileSheet;		private var rect:Rectangle; 		private var point:Point;		public var animationDelay:int=3;		public var animationCount:int=0;		public var animationLoop:Boolean=false;		public var tileList:Array;		public var currentTile:int;		public var tileWidth:Number;		public var tileHeight:Number;		public var nextX:Number=0;		public var nextY:Number = 0;		public var dx:Number=0;		public var dy:Number = 0;		public var doCopyPixels:Boolean = false;		public var loopCounter:int = 0; // counts the number of animation loops if useCounter is set to true;		public var useLoopCounter:Boolean = false;				//new		public var currentScaleX:int;		public var currentScaleY:int;		public var screenLocation:Point=new Point();		public var screenYLocation:Number;		private var bitmapRotationMatrix:Matrix = new Matrix();		private var bitmapScaleMatrix:Matrix;								public function BlitBitmap(tileSheet:TileSheet, tileList:Array, firstFrame:int) {			this.tileSheet = tileSheet;			tileWidth = tileSheet.tileWidth;			tileHeight = tileSheet.tileHeight;			this.tileList = tileList;			rect = new Rectangle(0, 0, tileWidth, tileHeight);			point = new Point(0, 0);			bitmapData = new BitmapData(tileWidth, tileHeight, true, 0x00000000);			currentTile = firstFrame;			renderCurrentTile(true );				}				public function updateCurrentTile():void {			if (animationLoop) {				if (animationCount > animationDelay) {					animationCount = 0;					currentTile++;					doCopyPixels = true;					if (currentTile > tileList.length - 1) {						currentTile = 0;						if (useLoopCounter) loopCounter++;					}				}				animationCount++;			}					}				public function renderCurrentTile(forceCopyPixels:Boolean=false):void {			//switch to scrollRect instead of copy pixels for BlitBitmap									//replace with scrollRect			if (forceCopyPixels) {				doCopyPixels = true;			}												if (doCopyPixels) {				bitmapData.lock();				rect.x=int(tileList[currentTile] % tileSheet.tilesPerRow)*tileWidth;				rect.y=int(tileList[currentTile] / tileSheet.tilesPerRow)*tileHeight;				bitmapData.copyPixels(tileSheet.sourceBitmapData, rect, point);				bitmapData.unlock();			}						doCopyPixels = false;		}				public function rotateAroundCenter(rotation:Number):void {			var angleInRadians:Number = Math.PI * 2 * (rotation/ 360);			screenLocation.x = x;			screenLocation.y = y;									bitmapRotationMatrix.identity(); //resets the matrix						//bitmapRotationMatrix.translate(-.5*width,-.5*height);			bitmapRotationMatrix.translate(-16,-16);			bitmapRotationMatrix.rotate(angleInRadians);			//bitmapRotationMatrix.translate(screenLocation.x+.5*width, screenLocation.y+.5*width);			bitmapRotationMatrix.translate(116, 116);						this.transform.matrix = bitmapRotationMatrix;		}				public function scaleFromCenter(xscale:Number, yscale:Number):void {			screenLocation.x = x;			screenLocation.y = y;			bitmapScaleMatrix.identity(); //resets the matrix			bitmapRotationMatrix.translate(-.5*width,-.5*height);			bitmapScaleMatrix.scale(xscale, yscale);			bitmapRotationMatrix.translate(screenLocation.x+.5*width, screenLocation.y+.5*width);			this.transform.matrix = bitmapScaleMatrix;		}				public function dispose():void {			bitmapData.dispose();			rect = null;			point = null;			tileList = null;		}			}	}